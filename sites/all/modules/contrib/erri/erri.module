<?php
/**
 * @file
 * Module main file
 */

/**
 * Implements hook_form_alter().  Determine if there are child entities, and act accordingly.
 */
function erri_form_alter(&$form, &$form_state, $form_id) {
  // Get a list of all delete forms via hook_erri_info().
  static $delete_forms = array();
  if ( empty($delete_forms) ) {
    module_load_include('inc', 'erri');
    foreach ( module_implements('erri_info') as $module ) {
      $function = $module . '_erri_info';
      $result = $function();
      if ( is_array($result) ) {
        $delete_forms += $result;
      }
    }
  }

  // If the current form is a delete form...
  if ( !empty($delete_forms[$form_id]) ) {
    $delete_form = &$delete_forms[$form_id];
    $parent_entity_info = entity_get_info($delete_form['target_type']);
    $form_copy = $form; // Keep the original form array 'safe'.
    $form_state_copy = $form_state; // Keep the original form_state array 'safe'.
    // ...and this is the delete version of the form for forms that serve multiple purposes...
    if ( empty($delete_form['is_delete_form']) ||
            function_exists($delete_form['is_delete_form']) && $delete_form['is_delete_form']($form_copy, $form_state_copy) ) {
      // If 'entity' is specified in the delete from, then this is a single instance delete form.
      if ( !empty($delete_form['entity']) && function_exists($delete_form['entity']) ) {
        $single_item = TRUE;
        // Retrieve the entity being deleted from the form.
        $parent_entity = $delete_form['entity']($form_copy, $form_state_copy);
        // Get the entity's ID.
        $id = $parent_entity->{$parent_entity_info['entity keys']['id']};
        $bundle = !empty($parent_entity_info['entity keys']['bundle'])
                ? $parent_entity->{$parent_entity_info['entity keys']['bundle']}
                : NULL;
        $child_entities = erri_get_child_entities($delete_form['target_type'], $id, $bundle);
        // Keep the field names to avoid redoing the work in the delete submit handler
        // if the entity can indeed be deleted (all children have the parent as optional.
        $field_names = array($id => array_keys($child_entities));
        $title = entity_label($delete_form['target_type'], $parent_entity);
      }
      // If 'entities' is specified, then this is a multi-entity delete form.
      elseif ( !empty($delete_form['entities']) && function_exists($delete_form['entities']) ) {
        $single_item = FALSE;
        $child_entities = array();
        // Get the entities from the form.
        $parent_entities = $delete_form['entities']($form_copy, $form_state_copy);
        $parent_entity_ids = element_children($parent_entities);
        $field_names = array();
        foreach ( $parent_entity_ids as $id ) {
          // Get the full entity via the entity's load function.
          $parent_entity = $parent_entity_info['load hook']($id);
          // Group index is used as a title for a section.
          $uri = entity_uri($delete_form['target_type'], $parent_entity);
          // Ensure unique array index by combining label and uri path.
          $group_index = l(entity_label($delete_form['target_type'], $parent_entity), $uri['path']);
          $bundle = !empty($parent_entity_info['entity keys']['bundle'])
                  ? $parent_entity->{$parent_entity_info['entity keys']['bundle']}
                  : NULL;
          $child_entities[$group_index] = erri_get_child_entities($delete_form['target_type'], $id, $bundle);
          if ( empty($child_entities[$group_index]) ) {
            unset($child_entities[$group_index]);
          }
          else {
            // Keep the field names to avoid redoing the work in the delete submit handler
            // if the entity can indeed be deleted (all children have the parent as optional.
            $field_names[$id] = array_keys($child_entities[$group_index]);
          }
        }
        $title = strtolower($parent_entity_info['plural label']);
      }

      if ( !empty($child_entities) ) {
        // Get the description and submit elements of the form.
        if ( !empty($delete_form['description_element']) ) {
          $element_trail = explode('][', $delete_form['description_element']);
          $description_element = &$form;
          foreach ( $element_trail as $element ) {
            $description_element = &$description_element[$element];
          }
        }
        else {
          $description_element = &$form['description']['#markup'];
        }
        if ( !empty($delete_form['submit_element']) ) {
          $element_trail = explode('][', $delete_form['submit_element']);
          $submit_element = &$form;
          foreach ( $element_trail as $element ) {
            $submit_element = &$submit_element[$element];
          }
        }
        else {
          $submit_element = &$form['actions']['submit'];
        }
        // Start by assuming no fields are required and the current user has edit
        // permissions.  Then evaulate field-by-field and for each referenced entity,
        // and change accordingly (done in the called functions, so vars passed by
        // reference).
        $has_required = FALSE;
        $has_edit_permissions = TRUE;
        if ( $single_item ) {
          $list = _erri_list_children($child_entities, $has_required, $has_edit_permissions);
          if ( $has_required || !$has_edit_permissions ) {
            drupal_set_title(t('Cannot delete %title', array('%title' => $title)), PASS_THROUGH);
            $description_element = '<div class="erri">' . t('%title cannot be deleted because it is referred to by:',
                    array('%title' => $title));
          }
          else {
            $description_element .= '<div class="erri">' . t('%title cannot be deleted without emptying:',
                    array('%title' => $title));
          }
        }
        else {
          $list = array();
          foreach ( $child_entities as $parent_entity => $children ) {
            $sub_list = _erri_list_children($children, $has_required, $has_edit_permissions);
            $list[] = t('!entity is referred to by:', array('!entity' => $parent_entity)) . '<ul><li>' . implode('</li><li>', $sub_list) . '</li></ul>';
          }
          if ( $has_required || !$has_edit_permissions ) {
            drupal_set_title(t('Cannot delete one or more of the @title', array('@title' => $title)));
            $description_element = '<div class="erri">' . t('One or more of the @title cannot be deleted because:',
                    array('@title' => $title));
          }
          else {
            $description_element .= '<div class="erri">' . t('One or more of the @title cannot be deleted without emtpying referring fields:',
                    array('@title' => $title));
          }
        }

        $description_element .= '<ul class="erri-referrers"><li>' . implode('</li><li>', $list) . '</li></ul>';
        if ( $has_required || !$has_edit_permissions ) {
          if ( $has_required ) {
            $description_element .= '<p><span class="form-required" title="' .
                    t('This field is required.') . '">*</span> ' .
                    t('Required field - cannot be left blank.') . '</p>';
          }
          if ( !$has_edit_permissions ) {
            $description_element .= '<p>' .
                    t('You do not have sufficient permissions on all referring items and / or fields to be able to delete this entity.') .
                    '</p>';
          }
          $submit_element['#disabled'] = TRUE;
        }
        else {
          $submit_element['#suffix'] = t('and empty <strong>all</strong> referring fields.') . ' ' .
                  ( !empty($submit_element['#suffix']) ? $submit_element['#suffix'] : '' ) . ' &nbsp; &nbsp; ';
          $submit_element['#attributes']['title'] = t('Click to delete and empty all referring fields');
          $form['erri_entities_and_field_names'] = array('#type' => 'value', '#value' => $field_names);
          $form['#submit'][] = 'erri_delete_form_submit';
        }
        $description_element .= '</div>';
        $form['#attached']['css'][] = drupal_get_path('module', 'erri') . '/erri.css';
      }
    }
  }
}

/**
 * Assemble all child entities of a parent entity for referential integrity check.
 * @param string $parent_entity_type The entity_type of the parent entity (eg., 'node', 'user', 'taxonomy_term', etc.).
 * @param int $id The ID of the parent entity.
 * @param string $bundle The bundle of the parent in the case that the parent entity type uses bundles.
 * @return array Child entities referring to the parent, keyed on the referencing field with sub-arrays of the
 *   entities referencing, or an empty array if no entities refer to the parent.
 */
function erri_get_child_entities($parent_entity_type, $id, $bundle = NULL) {
  $child_entities = array();
  $reference_fields = erri_get_reference_fields();
  if ( !empty($reference_fields) ) {
    $entity_info = entity_get_info();
    foreach ( $reference_fields as $field ) {
      // If it's an entityreference referring to the right entity type, or...
      if ( ( !empty($field['type']) && (
              $field['type'] == 'entityreference' && !empty($field['settings']['target_type']) &&
              $field['settings']['target_type'] == $parent_entity_type ||
              // ...it's a taxonomy term reference and we're testing against a taxonomy term, and...
              $field['type'] == 'taxonomy_term_reference' && $parent_entity_type == 'taxonomy_term' ) &&
              // ...the field is in fact being used, and...
              !empty($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']) && (
              // ...and either the form isn't for an entity type that uses bundles, or...
              empty($bundle) || empty($field['settings']['handler_settings']['target_bundles']) ||
              // ...the entity's bundle is one of the field's target bundles...
              is_array($field['settings']['handler_settings']['target_bundles']) &&
              in_array($bundle, $field['settings']['handler_settings']['target_bundles']) ) ) ) {
        $child_entities[$field['field_name']] = array();
        foreach ( $field['storage']['details']['sql']['FIELD_LOAD_CURRENT'] as $table => $column ) {
          $column_name = current($column);
          // Use the CONCAT in the select to ensure a unique primary key and thus index on the array
          // so that array arithmatic doesn't stomp on array elements.
          $child_entities[$field['field_name']] += db_query("SELECT *, "
                  . "CONCAT(entity_type, ':', bundle, ':', entity_id, ':', revision_id) AS pk, "
                  . "'current' AS revision FROM {{$table}} "
                  . "WHERE $column_name = :id AND deleted = 0", array(':id' => $id))->fetchAllAssoc('pk');
        }
        // Now see if there are any previous revisions.
        if ( !empty($field['storage']['details']['sql']['FIELD_LOAD_REVISION']) ) {
          foreach ( $field['storage']['details']['sql']['FIELD_LOAD_REVISION'] as $table => $column ) {
            $column_name = current($column);
            $query = db_select($table, $table)
                    ->fields($table)
                    ->condition($column_name, $id)
                    ->condition('deleted', 0);
            // Use the CONCAT in the select to ensure a unique primary key and thus index on the array
            // so that array arithmatic doesn't stomp on array elements.
            $query->addExpression("CONCAT($table.entity_type, ':', $table.bundle, ':', $table.entity_id, ':', $table.revision_id)", 'pk');
            $query->addExpression("'revision'", 'revision');
            if ( !empty($field['settings']['target_type']) &&
                    !empty($entity_info[$field['settings']['target_type']]['revision table']) &&
                    !empty($entity_info[$field['settings']['target_type']]['entity keys']['id']) &&
                    !empty($entity_info[$field['settings']['target_type']]['entity keys']['revision']) &&
                    db_field_exists($entity_info[$field['settings']['target_type']]['revision table'], 'timestamp')) {
              $revision_entity_info = &$entity_info[$field['settings']['target_type']];
              $query->addJoin('inner', $revision_entity_info['revision table'],
                      'r', "$table.entity_id = r.{$revision_entity_info['entity keys']['id']} AND "
                      . "$table.revision_id = r.{$revision_entity_info['entity keys']['revision']} AND "
                      . "$table.entity_type = '{$field['settings']['target_type']}'");
              $query->addField('r', 'timestamp', 'revision_timestamp');
            }
            $child_entities[$field['field_name']] += $query->execute()->fetchAllAssoc('pk');
          }
        }
        if ( empty($child_entities[$field['field_name']]) ) {
          unset($child_entities[$field['field_name']]);
        }
        else {
          krsort($child_entities[$field['field_name']]);
        }
      }
    }
  }
  foreach ( module_implements('erri_reference_check') as $module ) {
    $function = $module . '_erri_reference_check';
    $result = $function($parent_entity_type, $id, $bundle);
    if ( is_array($result) ) {
      $child_entities += $result;
    }
  }
  return $child_entities;
}

/**
 * Helper function to get all reference fields.
 * @staticvar array $reference_fields All reference fields.
 * @return array All reference fields.
 */
function erri_get_reference_fields() {
  static $reference_fields = array();
  if ( empty($reference_fields) ) {
    $reference_fields = field_read_fields(array('type' => 'entityreference'));
    $reference_fields += field_read_fields(array('type' => 'taxonomy_term_reference'));
    // Allow other modules to add to the reference fields.
    foreach ( module_implements('erri_reference_fields') as $module ) {
      $function = $module . '_erri_reference_fields';
      $additional_fields = $function();
      if ( is_array($additional_fields) ) {
        $reference_fields += $additional_fields;
      }
    }
  }
  return $reference_fields;
}

/**
 * Helper function to arrange child entities in an array of strings.
 * @param array $child_entities An array of child entities to be listed.
 * @param bool $has_required Passed by reference, a flag indicating if any of the
 *   listed fields are required fields.
 * @param bool $has_edit_permissions Passed by reference, a flag indicating if the
 *   current user has permissions to edit all child entities.
 * @return array The list of strings.
 */
function _erri_list_children($child_entities, &$has_required, &$has_edit_permissions) {
  foreach ( $child_entities as $field_name => $children ) {
    foreach ( $children as $child ) {
      $list[] = _erri_get_reference($child, $field_name, $has_required, $has_edit_permissions);
    }
  }
  return $list;
}

/**
 * Helper function to specify the wording and link around a reference.
 * @param object $child The child entity with the reference.
 * @param string $field_name The machine name of the field referencing the child.
 * @param bool $has_required Passed by reference, a flag indicating if any of the
 *   previous listed fields are required fields, and set to TRUE if this field's
 *   instance is required.
 * @param bool $has_edit_permissions Passed by reference, a flag indicating if the
 *   current user has permissions to edit all child entities.
 * @return string The referencing message.
 */
function _erri_get_reference($child, $field_name, &$has_required, &$has_edit_permissions) {
  if ( is_array($child) ) {
    // This is a custom value, as otherwise $child would be an object.
    if ( !empty($child['#markup']) ) {
      if ( !empty($child['#required']) ) {
        $has_required |= $child['#required'];
      }
      if ( !empty($child['#has_permissions']) ) {
        $has_edit_permissions &= $child['#has_permissions'];
      }
      $reference = $child['#markup'];
      if ( !empty($child['#required']) ) {
        $reference = '<span class="erri-required-reference">' . $reference . '</span>';
      }
      return $reference;
    }
    else {
      watchdog('erri', 'Custom markup not set.', WATCHDOG_ERROR);
      $has_required = TRUE; // Just set this as a default.
      $has_edit_permissions = FALSE;
      return t('something else on the site') . ' <span class="form-required" title="' .
              t('This field is required.') . '">*</span>';
    }
  }
  $entity_info = entity_get_info($child->entity_type);
  if ( function_exists($entity_info['load hook']) ) {
    try {
      $child_entity = $entity_info['load hook']($child->entity_id);
    }
    catch ( Exception $e ) {
    }
  }
  else {
    watchdog('erri', 'Load function %function does not exist for @type @id.', array(
        '%function' => $entity_info['load hook'],
        '@type' => $child->entity_type,
        '@id' => $child->entity_id,
      ), WATCHDOG_ERROR);
    $has_required = TRUE; // Just set this as a default.
    $has_edit_permissions = FALSE;
    return t('something else on the site') . ' <span class="form-required" title="' .
            t('This field is required.') . '">*</span>';
  }
  if ( !empty($entity_info['entity keys']['bundle']) ) {
    $type = $child_entity->{$entity_info['entity keys']['bundle']};
    $type_name = $entity_info['bundles'][$child_entity->{$entity_info['entity keys']['bundle']}]['label'];
  }
  else {
    $type = $child->entity_type;
    $type_name = $entity_info['label'];
  }
  $field = field_info_field($field_name);
  $field_instance = field_info_instance($child->entity_type, $field_name, $type);
  $required = $field_instance['required'] ? ' <span class="form-required" title="' .
          t('This field is required.') . '">*</span>' : '';
  $reference = t('a field!required in a content item', array('!required' => $required));
  $has_required |= $field_instance['required'];
  $has_edit_permissions &= entity_access('update', $child->entity_type, $child_entity) &&
          field_access('update', $field, $child->entity_type, $child_entity);
  if ( entity_access('view', $child->entity_type, $child_entity) &&
          field_access('view', $field, $child->entity_type, $child_entity) ) {
    $uri = entity_uri($child->entity_type, $child_entity);
    if ( !($name = entity_label($child->entity_type, $child_entity)) ) {
      $name = t('with id @id', array('@id' => $child->entity_id));
    }
    $reference = t('field %field!required in !revision @type !name', array(
      '%field' => $field_instance['label'],
      '!required' => $required,
      '!revision' => $child->revision == 'revision'
            ? ( !empty($child->revision_timestamp)
              ? t('the !ts revision of', array('!ts' => format_date($child->revision_timestamp)))
              : t('a previous revision of') )
            : '',
      '@type' => strtolower($type_name),
      '!name' => l($name, $uri['path']),
    ));
    if ( $field_instance['required'] ) {
      $reference = '<span class="erri-required-reference">' . $reference . '</span>';
    }
  }
  return $reference;
}

/**
 * Additional submit handler to set null target IDs when the referring fields do
 * not require a value, and the user has decided to delete the referred-to entity
 * anyway.
 * @param array $form The form render array.
 * @param array $form_state The state of the form.
 */
function erri_delete_form_submit($form, &$form_state) {
  $reference_fields = erri_get_reference_fields();
  $rows = 0;
  foreach ( $form_state['values']['erri_entities_and_field_names'] as $entity_id => $field_names ) {
    foreach ( $field_names as $field_name ) {
      $field = $reference_fields[$field_name];
      foreach ( array('FIELD_LOAD_CURRENT', 'FIELD_LOAD_REVISION') as $revision ) {
        if ( empty($field['storage']['details']['sql'][$revision]) ) {
          continue;
        }
        foreach ( $field['storage']['details']['sql'][$revision] as $table => $column ) {
          $column_name = current($column);
          $rows += db_delete($table)->condition($column_name, $entity_id)->execute();
        }
      }
    }
  }
  drupal_flush_all_caches();
  drupal_set_message(format_plural($rows, 'One reference emptied.', '@count references emptied.'));
}
