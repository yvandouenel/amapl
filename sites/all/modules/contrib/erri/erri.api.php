<?php
/**
 * @file
 * Hooks provided by the Entity Reference Referential Integrity API.
 */

/**
 * @addtogroup hooks
 * @{
 */

/**
 * Provide an array of information on all delete forms for which you want referential
 * integrity checked.  Each element of the return array is itself an array, keyed
 * on the form ID of the delete form it is describing.  Each sub element can have
 * the following key-value pairs:
 *   'entity' => Required for single-entity delete forms, and cannot be present for
 *         multi-entity delete forms.  Specifies the function to call to return the
 *         entity that is being deleted.  This function will be passed the form array.
 *   'entities' => Required for multi-entity delete forms, and cannot be present for
 *         single-entity delete forms.  Specifies the function to call to return an
 *         array with the keys being the entity IDs that are being deleted.  This
 *         function will be passed the form array.
 *   'target_type' => Required.  The machine name of the entity type being deleted.
 *   'is_delete_form' => If the form ID is used for various versions of the form,
 *         this specifies the name of the function to call to determine if the form
 *         is in its delete mode.  This function will be passed the form array.
 *   'description_element' => If not using the function confirm_form() to create
 *         your module's delete confirmation form, specify the element on your
 *         own confirmation form that can hold a description of any referring
 *         entities and other referential integrity messages generated by this
 *         module.  Text will be concatenated to this form element.  For example,
 *         if the description markup for your form is $form['field_group']['markup_field']['#markup'],
 *         specify a string in the form 'field_group][markup_field][#markup'.
 *         Defaults to 'description][#markup', which is where it is when the delete
 *         confirmation form is generated by confirm_form().
 *   'submit_element' => If not using the function confirm_form() to create
 *         your module's delete confirmation form, specify the element on your
 *         own confirmation form that is the delete button.  For example, if the
 *         submit button for your form is $form['field_group']['buttons_and_links']['submit'],
 *         specify a string in the form 'field_group][buttons_and_links][submit'.
 *         Defaults to 'actions][submit', which is where it is when the delete
 *         confirmation form is generated by confirm_form().
 *
 *   @see erri.inc
 */
function hook_erri_info() {
  return array(
    'my_delete_form_using_confirm_form' => array(
      'entity' => 'my_function_to_get_the_entity',
      'target_type' => 'my_entity_type',
      'is_delete_form' => 'my_function_to_determine_if_this_is_the_delete_version_of_the_form',
    ),
    'my_multi_delete_form_not_using_confirm_form' => array(
      'entities' => 'my_function_to_get_array_of_entities',
      'target_type' => 'my_entity_type',
      'is_delete_form' => 'my_function_to_determine_if_this_is_the_delete_version_of_the_form',
      'description_element' => 'message_area][ri_messages][#markup',
      'submit_element' => 'form_bottom][buttons][delete_all',
    ),
  );
}

/**
 * Provide additional fields to Entity Reference Referential Integrity to check.
 * The hook should return an array by field name with each field type either
 * entityreference or taxonomy_term_reference.  This will require overriding the
 * actual field type to indicate to what the column specified as the referring
 * column is actually pointing.  Note that these fields must be fields defined
 * through the fields API.
 *
 * @return array An array of fields in the same format as would be returned by
 *   field_read_fields().
 */
function hook_erri_reference_fields() {
  $fields = array(
    'my_field_name' => array(
      'type' => 'entityreference',
      'settings' => array(
        'target_type' => 'node',
        'handler_settings' => array(
          'target_bundles' => array('my_bundle', 'my_other_bundle'),
        ),
      ),
      'storage' => array(
        'details' => array(
          'sql' => array(
            'FIELD_LOAD_CURRENT' => array(
              'field_data_field_my_field_name' => array(
                'target_id' => 'field_my_field_name_target_id',
              ),
            ),
          ),
        ),
      ),
    ),
  );
  $other_fields = field_read_fields(array('type' => 'my_field_type'));
  foreach ( $other_fields as &$field ) {
    $field['type'] = 'entityreference'; // Override the field type to have it checked.
    $field['settings']['target_type'] = 'node'; // Set this if it isn't set in the field definition.
    foreach ( array_keys($field['storage']['details']['sql']['FIELD_LOAD_CURRENT']) as $table ) {
      // ERRI only uses the reference column, so override the 'table' array with just one column.
      $field['storage']['details']['sql']['FIELD_LOAD_CURRENT'][$table] = array('target_id' => 'field_the_entity_reference_column_name');
    }
  }
  return $fields + $other_fields;
}

/**
 * Allow custom modules to provide their own, non-field API reference information.
 * @param string $parent_entity_type The entity_type of the parent entity (eg., 'node', 'user', 'taxonomy_term', etc.).
 * @param int $id The ID of the parent entity.
 * @param string $bundle The bundle of the parent in the case that the parent entity type uses bundles.
 * @return array An array whose keys are the unique machine names of the referencing fields / locations, each pointing
 *   to an array of unique referrer ids, each pointing to an array of properties as indicated below:
 *   '#markup': The string that should be displayed to the end user.  If there are permission issues, your module
 *       should take care of any adjustment to this string to reflect those permissions.
 *   '#required': TRUE if the referring location requires there to be a value.  If this is true, the '#markup' should
 *       also indicate that to the end user.
 *   '#has_permissions' => TRUE if the current user has update permissions on the referring location.
 * For each location key, it is good practice to preface it with your module's name to avoid any name-space collisions.  If
 * the parent entity is not used anywhere in your module, simply return nothing.
 */
function hook_erri_reference_check($parent_entity_type, $id, $bundle = NULL) {
  $where = my_module_entitiy_is_in_use($parent_entity_type, $id);
  if ( !empty($where) ) {
    $child_entities = array();
    foreach ( $where as $referrer_id => $referrer ) {
      $child_entities['my_module_custom_location'] = array(
        $referrer_id => array(
          '#markup' => t('%location!required in %referrer', array(
            '%location' => $referrer->referring_location_string,
            '!required' => $referrer->referring_required ? ' <span class="form-required" title="' .
                    t('This field is required.') . '">*</span>' : '',
            '%referrer' => $referrer->referrer_label_string,
          )),
          '#required' => $referrer->referring_required,
          '#has_permissions' => my_module_current_user_has_edit_permissions($parent_entity_type, $id),
        ),
      );
    }
    return $child_entities;
  }
}


/**
 * @} End of "addtogroup hooks".
 */
